---
description: Mobile-specific performance optimization techniques for React Native apps
globs: ["src/**/*.{ts,tsx}", "App.tsx", "src/screens/**/*.tsx"]
alwaysApply: true
---

# Performance Optimization

## State Management Performance

* Minimize useState, useEffect, and heavy computations inside render methods
* Prefer derived state and memoization over useState when possible
* Use Zustand stores for global state with selector patterns to prevent unnecessary re-renders
* Example: `const count = useStore(state => state.count)` not `const store = useStore()`

## Component Memoization

* Use React.memo() for components with static or infrequent prop changes
* Use useMemo for expensive calculations that depend on specific dependencies
* Use useCallback for event handlers passed to child components to prevent re-creation
* Don't over-memoize; profile performance to identify actual bottlenecks

## FlatList Optimization

* Use removeClippedSubviews prop for better memory usage with large lists
* Implement getItemLayout when items have consistent sizes for instant scrolling
* Use initialNumToRender to control initial batch size
* Set maxToRenderPerBatch and windowSize appropriately
* Example:
  ```typescript
  <FlatList
    removeClippedSubviews
    getItemLayout={(data, index) => ({ length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index })}
    initialNumToRender={10}
    maxToRenderPerBatch={10}
    windowSize={10}
  />
  ```

## Anonymous Function Prevention

* Do NOT use anonymous functions in renderItem or event handlers
* Define handlers outside render or use useCallback
* Bad: `<FlatList renderItem={({ item }) => <Row item={item} />} />`
* Good: `const renderRow = useCallback(({ item }) => <Row item={item} />, []);`

## Image Optimization

* Use expo-image or react-native-fast-image instead of default Image component
* Use WebP format where supported for better compression
* Implement lazy loading for images outside viewport
* Provide image dimensions to prevent layout shifts
* Cache images appropriately

## Code Splitting

* Use React.lazy + Suspense for non-critical screens to reduce initial bundle size
* Lazy load heavy components like modals and complex views
* Example: `const SettingsScreen = React.lazy(() => import('./screens/Settings'));`

## Battery Conservation

* Minimize background tasks using expo-task-manager wisely
* Use battery-conscious APIs: `expo-battery`, `advancedBatteryManager`
* Implement power-saving modes for emergency scenarios
* Monitor battery usage: `src/services/AdvancedBatteryManager`

## Memory Management

* Be aware of memory limits: iOS ~1.5GB, Android varies by device
* Profile memory usage with Flipper or React Native DevTools
* Avoid memory leaks: unsubscribe from listeners in cleanup
* Clear large data structures when no longer needed
* Use WeakMap/WeakSet for caches that should be garbage collected

## Native Bridge Optimization

* Reduce bridge calls by batching native operations
* Batch BLE operations, sensor readings, and location updates
* Use native modules efficiently with proper threading
* Cache native module results when possible

## List Rendering

* Use FlatList or SectionList instead of ScrollView + map for large lists
* Implement proper keyExtractor for list items
* Avoid complex layouts in list items
* Use VirtualizedList for very large datasets

## Render Optimization

* Keep render methods fast and side-effect free
* Move heavy computations outside render or into useMemo
* Avoid creating objects/arrays in render (use useMemo or constants)
* Destructure props/state at component level, not in JSX

## Async Operations

* Handle async operations properly with try/catch
* Use Promise.all for parallel independent operations
* Cancel/abort async operations when components unmount
* Use AbortController for fetch requests

## Background Processing

* Use expo-task-manager for background tasks (see src/background/)
* Keep background tasks minimal and efficient
* Example background tasks: `quakeTask`, `relayTask`, `offlineSyncManager`

## Network Optimization

* Implement request caching and offline-first strategies
* Use Network Intelligence Engine: `src/services/NetworkIntelligenceEngine`
* Batch network requests when possible
* Handle network errors gracefully

## Animation Performance

* Use react-native-reanimated for performant animations
* Use native driver for animations when possible: `useNativeDriver: true`
* Keep animations on 60fps by using worklets
* Avoid animating layout properties in large lists

## Profiling Tools

* Use Flipper for performance profiling
* Use React DevTools Profiler to identify slow renders
* Monitor bundle size with expo-analyze
* Track memory usage with native profiling tools
